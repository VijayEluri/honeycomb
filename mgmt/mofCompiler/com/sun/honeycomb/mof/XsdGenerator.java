/*
 * Copyright © 2008, Sun Microsystems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 *    * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 *    * Neither the name of Sun Microsystems, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



package com.sun.honeycomb.mof;

import java.io.FileWriter;
import java.io.IOException;
import javax.wbem.cim.CIMException;
import javax.wbem.cim.CIMClass;
import java.util.Vector;
import javax.wbem.cim.CIMProperty;
import javax.wbem.cim.CIMDataType;
import javax.wbem.cim.CIMTypedElement;
import javax.wbem.cim.CIMElement;
import java.util.Iterator;
import javax.wbem.cim.CIMMethod;
import java.util.ArrayList;
import javax.wbem.cim.CIMParameter;

public class XsdGenerator {

    private static final String HEADER1 = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\n"+
        "<!-- This file has been automatically generated by the Honeycomb CIMCompiler ...\n"+
        "     DO NOT EDIT !!! -->\n\n"+
        "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n"+
        "  xmlns:jaxb=\"http://java.sun.com/xml/ns/jaxb\"\n"+
        "  xmlns:xjc=\"http://java.sun.com/xml/ns/jaxb/xjc\"\n";
    private static final String HEADER2 = "  jaxb:version=\"2.0\">\n\n";

    private static final String CLIENT_EXTRA_HEADER = "  <xs:annotation>\n"+
        "     <xs:appinfo>\n"+
        "        <jaxb:globalBindings>\n"+
        "          <xjc:superClass name=\"com.sun.honeycomb.mgmt.client.ClientData\"/>\n"+
        "        </jaxb:globalBindings>\n"+
        "     </xs:appinfo>\n"+
        "  </xs:annotation>\n\n";

    private static final String FOOTER = "</xs:schema>\n";
    
    private FileWriter output;
    private boolean clientMode;
    private String packageName;
    private ArrayList definedTypes;

    public XsdGenerator(String outputFile,
                        boolean _clientMode) 
        throws IOException {
        output = new FileWriter(outputFile);
        clientMode = _clientMode;
        packageName = System.getProperty("rootPackage");
        if (clientMode) {
            packageName += ".client";
        } else {
            packageName += ".server";
        }
        definedTypes = null;
    }

    public void generate(CompilerBackend mofSpec)
        throws CIMException, IOException {
        String clientString = clientMode ? "client" : "server";
        System.out.println("Generating the xsd "+clientString+" file");
        
        output.write(HEADER1);
        if (clientMode) {
            output.write("  xmlns:hc=\"http://www.sun.com/honeycomb\"\n"+
                         "  jaxb:extensionBindingPrefixes=\"xjc hc\"\n");
        } else {
            output.write("  jaxb:extensionBindingPrefixes=\"xjc\"\n");
        }
        output.write(HEADER2);
        if (clientMode) {
            output.write(CLIENT_EXTRA_HEADER);
        }

        definedTypes = new ArrayList();

        CIMClass[] classes = mofSpec.getAllClasses();
        for (int i=0; i<classes.length; i++) {
            generateClass(classes[i]);
        }

        for (int i=0; i<definedTypes.size(); i++) {
            String name = (String)definedTypes.get(i);
            output.write("  <xs:element name=\"JAXB"+name+"\" type=\""+
                         name+"\"/>\n");
        }
        
        output.write(FOOTER);
    }

    private void generateProperty(CIMTypedElement prop,
                                  String prefix,
                                  StringBuffer sb) 
        throws CIMException {
        sb.append(prefix);
        sb.append("      <xs:element name=\"");
        sb.append(prop.getJavaName());
        sb.append("\"\n");

        sb.append(prefix);
        sb.append("        type=\"");
        Utils.XsdEncoding encoding = Utils.mofToXsd(prop.getType());
        sb.append(encoding.type);
        sb.append("\"");
        if (encoding.extraDef != null) {
            sb.append(" "+encoding.extraDef);
        }

        sb.append("/>\n");
    }

    private void generateXML(StringBuffer sb,
                             String typeName,
                             String superType,
                             Vector props,
                             GenerateCallback callback)
        throws CIMException {


        for (int i=0; i<props.size(); i++) {
             CIMDataType type = ((CIMTypedElement)props.get(i)).getType();
             if (type.getType() == CIMDataType.XML) {
                 return;
             }
        }

        sb.append("  <xs:complexType name=\"");
        sb.append(typeName);
        sb.append("\">\n");
        
        if (callback != null) {
            callback.callback(sb);
        }

//         if (clientMode) {
//             sb.append("    <xs:annotation>\n"+
//                       "      <xs:appinfo>\n"+
//                       "        <jaxb:class name=\"");
//             sb.append(klass.getJavaName());
//             sb.append("\"\n"+
//                       "          implClass=\"");
//             sb.append(packageName+"."+klass.getJavaName()+"Impl");
//             sb.append("\"/>\n"+
//                       "      </xs:appinfo>\n"+
//                       "    </xs:annotation>\n");
//         }
        
        String prefix = "";
        if (superType != null) {
            prefix = "    ";
            sb.append("    <xs:complexContent>\n"+
                      "      <xs:extension base=\""+superType+"\">\n");
        }
        sb.append(prefix+"    <xs:sequence>\n");
        for (int i=0; i<props.size(); i++) {
            generateProperty(((CIMTypedElement)props.get(i)),
                             prefix, sb);
        }
        sb.append(prefix+"    </xs:sequence>\n");
        if (superType != null) {
            sb.append("      </xs:extension>\n"+
                      "    </xs:complexContent>\n");
        }
        sb.append("  </xs:complexType>\n");
        sb.append("\n");

        definedTypes.add(typeName);
    }

    private void generateClass(CIMClass klass)
        throws IOException, CIMException {
        
        StringBuffer sb = new StringBuffer();

        // Generate the action types
        Iterator methods = klass.getAllMethods().iterator();
        while (methods.hasNext()) {
            CIMMethod method = (CIMMethod)methods.next();
            if (method.getParameters().size() > 0) {
                generateXML(sb, Utils.generateMethodTypeName(method, true), null, method.getParameters(),
                            null);
            }
            Vector m = new Vector();
            CIMMethod m2 = (CIMMethod)method.clone();
            m2.setName("value");
            m.add(m2);
            generateXML(sb, Utils.generateMethodTypeName(method, false), null, m,
                        null);
        }
        
        // Generate the class type
        String superType = klass.getSuperClass() == null
            ? null
            : CIMElement.nameToJava(klass.getSuperClass());

        if (clientMode) {
            generateXML(sb, klass.getJavaName(), superType, klass.getAllProperties(),
                        new ClassMethodGenerator(klass));
        } else {
            generateXML(sb, klass.getJavaName(), superType, klass.getAllProperties(),
                        null);
        }

        output.write(sb.toString());
    }

    public void close() {
        if (output == null) {
            return;
        }
        try {
            output.close();
        } catch (IOException e) {
        }
        output = null;
    }

    private interface GenerateCallback {
        public void callback(StringBuffer sb)
            throws CIMException;
    }

    private static class ClassMethodGenerator
        implements GenerateCallback {

        private CIMClass klass;

        private ClassMethodGenerator(CIMClass klass) {
            this.klass = klass;
        }

        public void callback(StringBuffer sb)
            throws CIMException {
            if (klass.getAllMethods().size() == 0) {
                return;
            }
            Iterator methods = klass.getAllMethods().iterator();
            sb.append("    <xs:annotation><xs:appinfo>\n");
            while (methods.hasNext()) {
                CIMMethod method = (CIMMethod)methods.next();
                String interactive = method.hasQualifier(Utils.INTERACTIVE_CIM_KEYWORD) ? "true" : "false";
                sb.append("        <hc:method name=\""+method.getJavaName()+"\" type=\""+
                          Utils.mofToJava(method.getType())+"\""+
                          " interactive=\""+interactive+"\">\n");
                Iterator parameters = method.getParameters().iterator();
                while (parameters.hasNext()) {
                    CIMParameter param = (CIMParameter)parameters.next();
                    sb.append("            <hc:arg name=\""+param.getJavaName()+"\" type=\""+
                              Utils.mofToJava(param.getType())+"\"/>\n");
                }
                sb.append("        </hc:method>\n");
            }
            sb.append("    </xs:appinfo></xs:annotation>\n");
        }
    }
}

            
