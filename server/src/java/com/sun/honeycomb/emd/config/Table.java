/*
 * Copyright © 2008, Sun Microsystems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 *    * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 *    * Neither the name of Sun Microsystems, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



package com.sun.honeycomb.emd.config;

import java.util.List;
import java.util.Map;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.io.PrintStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.ArrayList;
import java.io.Writer;

import java.util.logging.Logger;

public class Table {
    
    private static final Logger LOG = Logger.getLogger(Table.class.getName());

    //Limits for various fields

    // HADB max columns in table is 255.
    // All tables need a column for OBJECTID
    public static final int MAX_TABLE_COLUMNS_IN_ROW = 254;

    // HADB max row size is 8080. Apply this to Emulator as well.
    public static final int MAX_TABLE_ROW_LENGTH = 8080;

    // PER_ROW_OVERHEAD is determined by saying we should allow an
    // 8000-character string: (8080 - 2 bytes field length - XXX 
    // reserved) = 8000
    //   (XXX reserved must have room at least for 20 bytes of hadb overhead +
    //    30 bytes of OID, leaving currently approx 26 bytes for future 
    //    expansion)
    public static final int PER_ROW_OVERHEAD = 78;
    
    public static final String TAG_TABLE = "table";
    public static final String ATT_NAME = "name";
    public static final String ATT_AUTOGEN = "autogen";
    
    private String name;
    private int nextColumnIndex;
    private boolean factoryDefault;
    private boolean autoGenerated;
    private Map columns; // Iterator order needs to be insertion order
    private List indexes;
    
    /**
     * Constructor.
     */
    public Table(String name,
                 boolean factoryDefault,
                 boolean autoGenerated) {
        columns = new LinkedHashMap();
        nextColumnIndex = 0;
        this.name = name;
        this.factoryDefault = factoryDefault;
        this.autoGenerated = autoGenerated;
    }

    public void compareDirect(Table tb) 
        throws EMDConfigException {
        if (!name.equals(tb.getName())) {
            throw new EMDConfigException("The table " + name + 
              " in the hive  does not match the name of the table on " +
              "the remote new cell");
        }
        ArrayList list = new ArrayList();
        tb.getColumns(list);
        if (columns.size() != list.size()) {
            throw new EMDConfigException("The number of columns for the " +
              "table " + name + " differ between the hive and the remote " +
              " new cell");
        }
        for (int i = 0; i < list.size(); i++) {
            Column curColumn = getColumn(((Column) list.get(i)).getFieldName());
            if (curColumn == null) {
                throw new EMDConfigException("The column " +
                  ((Column) list.get(i)).getFieldName() +
                  " is missing for the table " + name + " on the hive ");
            }
        } 
    }

    /**
     * Check to see if this table is compatible with the specified
     * table.  If both table have the same name and the specified contains
     * all the columns in this table, then this table is compatible with 
     * the specified table.
     * @param tb Table to be compared with.
     * @throws EMDConfigException if this table is not compatile with
     * the specified tabble.
     */
    public void checkCompatibility(Table tb) 
        throws EMDConfigException {
        if (!name.equals(tb.getName())) {
            // table names are not the same.
            throw new EMDConfigException(
                    "table name differs for table " + name);
        }

        // verify all columns exist in the specfied table.
        Iterator it = columns.values().iterator();
        while (it.hasNext()) {
            Column c = (Column)it.next();
            if (null == tb.getColumn(c.getName())) {
                throw new EMDConfigException("column " + c.getName() +
                    " cannot be added to the existing table " + name + ".");
            }
        }
    }

    public String getName() {
        return(name);
    }
    
    public List getColumns() {
        return new ArrayList(columns.values());
    }

    public void getColumns(List list) {
        list.addAll(columns.values());
    }

    // (count does not include OBJECTID column)
    public int getColumnCount() {
        // there might be a removeColumn() method soon...
        return columns.size();
    }
    
    /**
     * Add Column to a this table.
     * @param field Field the new Column is referring to.
     */
    public void addColumn(Field field) {
        validateColumnField(field);
        nextColumnIndex++;
        Column col = new Column(this, field, nextColumnIndex);
        field.setTableColumn(col);
        columns.put(col.getFieldName(), col);
    }

    /**
     * Add Column to a this table.
     * @param name Field name the new Column is referring to.
     * @param namspace RootNamespace the field belongs to.
     * @throws IllegalArgumentException on erros.
     */
    public void addColumn(String name, RootNamespace namespace) {
        Field fd = null;
        if (namespace != null) {
            fd = namespace.resolveField(name);
        }
        if (fd == null) {
            throw new IllegalArgumentException(
                    "Cannot create column for field [" +
                    name + "] does not exist");
        }
        addColumn(fd);
    }

    /**
     * Validate the Field that the new column is referring to.
     * @throws IllegalArgumentException when validation failed.
     */
    protected void validateColumnField(Field fd) {
        if (fd == null) {
	        throw new IllegalArgumentException(
                    "Cannot create column for null field.");
        }        

        Column col = fd.getTableColumn();
        if (col !=  null && !name.equals(col.getTable().getName())) {
            throw new IllegalArgumentException(
                    "Cannot create column for field [" + fd.getName() + 
                    "] is already referenced by Column [" +
                    fd.getTableColumn().getName() + "]");
        }

        if (!fd.isQueryable()) {
	        throw new IllegalArgumentException(
                    "Cannot create column for field [" +
                    fd.getName() + "] is not queryable");
        }
    }

    public Column getColumn(String name) {
        return((Column)columns.get(name));
    }

    public boolean isAutoGenerated() {
        return autoGenerated;
    }

    public void export(Writer out,
                       String prefix,
                       boolean includeFactoryDefault)
            throws IOException {
        if (factoryDefault && (!includeFactoryDefault)) {
            return;
        }
        out.write( prefix + "<" + TAG_TABLE +
                   " " + ATT_NAME + "=\"" + name);

        if (autoGenerated) {
            out.write("\" " + ATT_AUTOGEN + "=\"true"); 
        }
        out.write("\" >\n");
        
        exportDependants(out, prefix + "  ", includeFactoryDefault);
        
        out.write(prefix + "</" + TAG_TABLE + ">\n");
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();

        sb.append("<TABLE \"");
        sb.append(name);
//        sb.append(" ==> ").append(tableName);
        sb.append("\">");
        return sb.toString();
    }
    
    public void validateTable() 
        throws EMDConfigException {

        int rowLength = Table.PER_ROW_OVERHEAD;
        int nCols = 0;
        
        Iterator ite = columns.values().iterator();
        while (ite.hasNext()) {
            Column col = (Column)ite.next();
            rowLength += col.getFieldSize();
            nCols++;
        }
        
        if (nCols > Table.MAX_TABLE_COLUMNS_IN_ROW) {
            throw new EMDConfigException(
                "Table [" + getName() + "] has " + nCols + 
                " columns.  Maximum number of columns allowed is " +
                Table.MAX_TABLE_COLUMNS_IN_ROW);
        }

        if (rowLength > Table.MAX_TABLE_ROW_LENGTH) { 
            throw new EMDConfigException(
                "Table [" + getName() + "] has " + rowLength + 
                " bytes per row. Maximum row length allowed is " +
                Table.MAX_TABLE_ROW_LENGTH);
        }
    }

    protected void exportDependants(Writer out,
            String prefix,
            boolean includeFactoryDefault)
            throws IOException {
        Iterator ite = columns.values().iterator();
        while (ite.hasNext()) {
            ((Column)ite.next()).export(out, prefix);
        }
    }
}
