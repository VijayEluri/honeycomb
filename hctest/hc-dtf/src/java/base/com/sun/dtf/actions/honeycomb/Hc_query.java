package com.sun.dtf.actions.honeycomb;

import java.io.IOException;
import java.util.ArrayList;



import com.sun.dtf.actions.conditionals.And;
import com.sun.dtf.actions.conditionals.Condition;
import com.sun.dtf.actions.conditionals.Eq;
import com.sun.dtf.actions.conditionals.Gt;
import com.sun.dtf.actions.conditionals.Lt;
import com.sun.dtf.actions.conditionals.Neq;
import com.sun.dtf.actions.conditionals.Or;
import com.sun.dtf.actions.honeycomb.util.NVOAPool;
import com.sun.dtf.exception.DTFException;
import com.sun.dtf.exception.ParseException;
import com.sun.dtf.exception.QueryException;
import com.sun.dtf.recorder.Event;
import com.sun.honeycomb.client.NameValueObjectArchive;
import com.sun.honeycomb.client.QueryResultSet;
import com.sun.honeycomb.common.ArchiveException;

/*
 * XXX: experimental class will be used to apply DTF queries to the cluster
 */
public class Hc_query extends HCObjectOperation {

    private String cursor = null;
    private String resultsPerFetch = "1000";

    public Hc_query() { }
    
    public void execute() throws DTFException {
        NameValueObjectArchive archive = 
              NVOAPool.getNVOA(getDatavip(), new Integer(getPort()).intValue());
     
        try {
            Event event = new Event(HCEventConstants.HC_QUERY_EVENT);
            QueryResultSet resultSet = null;
            
            Condition cond = (Condition)findFirstAction(Condition.class);
            String queryStr =  process(cond);
            
            event.start();
            resultSet = archive.query(queryStr,getResultsperfetch());
            event.stop();

            getLogger().info("HCQuery [" + queryStr + "]");
           
            /*
             * TODO: if we ever intend to have remote cursors the work will 
             *       have to start from here for being able to process the 
             *       cursors generated by remote hc_queries on other agents.
             */
            StringBuffer oids = new StringBuffer();
            while (resultSet.next()) { 
                oids.append(resultSet.getObjectIdentifier().toString());
                oids.append(",");
            }
            event.addAttribute("result.oids", oids.toString());
            
            getRecorder().record(event);
        } catch (ArchiveException e) {
            throw new DTFException("Error retrieving eobject.", e);
        } catch (IOException e) {
            throw new DTFException("Error retrieving object.", e);
        }
    }
    
    private String process(Condition cond) throws QueryException, ParseException {
        StringBuffer result = new StringBuffer();
        ArrayList children = cond.children();

        if (cond instanceof And) {
            StringBuffer aux = new StringBuffer("(");
          
            for (int i = 0; i < cond.children().size(); i++) {
                aux.append(process((Condition) children.get(i)));
                aux.append(" AND ");
            }
            
            result.append(aux.substring(0, aux.length() - " AND ".length()));
            result.append(")");
        } else if (cond instanceof Or) {
            StringBuffer aux = new StringBuffer("(");
           
            for (int i = 0; i < cond.children().size(); i++) {
                aux.append(process((Condition) children.get(i)));
                aux.append(" OR ");
            }
            
            result.append(aux.substring(0, aux.length() - " OR ".length()));
            result.append(")");
        } else {
            String compar = null;

            if (cond instanceof Eq)
                compar = "=";
            else if (cond instanceof Neq)
                compar = "<>";
            else if (cond instanceof Lt)
                compar = "<";
            else if (cond instanceof Gt)
                compar = ">";
            else
                throw new QueryException("Uknown conditional: "
                        + cond.getClass());

            String op1 = "", op2 = "";

            op1 = cond.getOp1();
            
            if (cond.getType().equals("int") || cond.getType().equals("long"))
                op2 = cond.getOp2();
            else
                op2 = "'" + cond.getOp2() + "'";

            result.append(op1 + compar + op2);
        }

        return result.toString();
    }
    
    public String getCursor() throws ParseException { return replaceProperties(cursor); }
    public void setCursor(String cursor) { this.cursor = cursor; }

    public int getResultsperfetch() throws ParseException  { 
        return toInt("resultsPerFetch",resultsPerFetch);
    }
    
    public void setResultsperfetch(String resultsPerFetch) { 
        this.resultsPerFetch = resultsPerFetch; 
    }
}
